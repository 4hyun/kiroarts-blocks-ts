/* wp:polyfill */
const cssUrlRegEx = /url\(\s*(?:(["'])((?:\\.|[^\n\\"'])+)\1|((?:\\.|[^\s,"'()\\])+))\s*\)/g;
const resolveUrl = (relativeUrl, baseUrl) => {
  try {
    return new URL(relativeUrl, baseUrl).toString();
  } catch (e) {
    return relativeUrl;
  }
};
const withAbsoluteUrls = (cssText, baseUrl) => cssText.replace(cssUrlRegEx, (_match, quotes = '', relUrl1, relUrl2) => `url(${quotes}${resolveUrl(relUrl1 || relUrl2, baseUrl)}${quotes})`);
const styleSheetCache = new Map();
const getCachedSheet = async (sheetId, factory) => {
  if (!styleSheetCache.has(sheetId)) {
    styleSheetCache.set(sheetId, factory());
  }
  return styleSheetCache.get(sheetId);
};
const sheetFromLink = async ({
  id,
  href,
  sheet: elementSheet
}, baseUrl) => {
  const sheetId = id || href;
  const sheetUrl = resolveUrl(href, baseUrl);
  if (elementSheet) {
    return getCachedSheet(sheetId, () => {
      const sheet = new CSSStyleSheet();
      for (const {
        cssText
      } of elementSheet.cssRules) {
        sheet.insertRule(withAbsoluteUrls(cssText, sheetUrl));
      }
      return Promise.resolve(sheet);
    });
  }
  return getCachedSheet(sheetId, async () => {
    const response = await fetch(href);
    const text = await response.text();
    const sheet = new CSSStyleSheet();
    await sheet.replace(withAbsoluteUrls(text, sheetUrl));
    return sheet;
  });
};
const sheetFromStyle = async ({
  textContent
}) => {
  const sheetId = textContent;
  return getCachedSheet(sheetId, async () => {
    const sheet = new CSSStyleSheet();
    await sheet.replace(textContent);
    return sheet;
  });
};
export const generateCSSStyleSheets = (doc, baseUrl = (doc.location || window.location).href) => [...doc.querySelectorAll('style,link[rel=stylesheet]')].map(element => {
  if ('LINK' === element.nodeName) {
    return sheetFromLink(element, baseUrl);
  }
  return sheetFromStyle(element);
});
//# sourceMappingURL=styles.js.map